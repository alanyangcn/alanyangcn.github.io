<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>杨立鹏的个人博客</title>
    <updated>2020-05-19T08:28:09.292Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>不积跬步无以至千里，不积小流无以成江海！</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2020, 杨立鹏的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[OpenGL入门（一) —— OpenGL专业名词解析]]></title>
        <id>http://localhost:4000/post/opengl-ru-men-yi-opengl-zhuan-ye-ming-ci-jie-xi</id>
        <link href="http://localhost:4000/post/opengl-ru-men-yi-opengl-zhuan-ye-ming-ci-jie-xi">
        </link>
        <updated>2019-12-11T03:12:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="opengl">OpenGL</h3>
<p><strong>OpenGL(Open Graphics Library)</strong> 是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。<br>
<strong>OpengGL ES(OpenGL for Embedded Systems)</strong> 是OpenGL的一个子集，针对手机、pad、游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。</p>
<h3 id="上下文context">上下文Context</h3>
<ul>
<li>
<p>在应用程序调用任何OpenGL的指令之前，需要安排⾸先创建⼀个OpenGL的 上下文。这个上下文是⼀个⾮常庞⼤的状态机，<strong>保存了OpenGL中的各种状态</strong>，这也是OpenGL指令执行的基础。</p>
</li>
<li>
<p>OpenGL的函数不管在哪个语⾔中，都是类似C语言⼀样的⾯向过程的函数，本质上都是<strong>对OpenGL上下文这个庞⼤的状态机中的某个状态或者对象进行操作</strong>，当然你得⾸先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调用封装成为⼀个⾯向对象的 图形API的。</p>
</li>
<li>
<p>由于OpenGL上下文是⼀个巨⼤的状态机，<strong>切换上下文往会产生较⼤的开销，但是不同的绘制模块，可能需要使⽤完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源</strong>。这样的方案，会⽐反复切换上下⽂，或者⼤量修改渲染状态，更加合理高效的。</p>
</li>
</ul>
<h3 id="状态机">状态机</h3>
<p>状态机是理论上的⼀种机器，这个非常难以理解。所以我们可以这么理解: 状态机描述了一个对象在其生命周期内所经历的各种状态，状态间的转变，发生转变的动因，条件及转变中所执行的活动。或者说状态机是一种行为，说明对象在其⽣命周期中响应事件所经历的状态序列以及对那些状态事件的响应。因此具有以下特点:</p>
<ul>
<li>有记忆功能，能<strong>记住其当前的状态</strong></li>
<li><strong>可以接收输入</strong>，根据输入的内容和⾃己的原先状态，修改⾃己当前状态，并且可以有对应输出</li>
<li>当进⼊**特殊状态(停机状态)**的时候，便不再接收输入，停⽌工作</li>
</ul>
<p>在OpenGL中，状态机的表现如下:</p>
<ul>
<li><strong>OpenGL可以记录⾃己的状态(如当前所使用的颜色、是否开启了深度测试、是否开启了混合功能等)</strong></li>
<li><strong>OpenGL可以接收输⼊(当调⽤OpenGL函数的时候，实际上可以看成 OpenGL在接收我们的输入)</strong>。如我们调用<span style="color:red">glColor3f</span>，则OpenGL接收到这个输⼊后会修改⾃己的“当前颜色”这个状态;</li>
<li><strong>OpenGL可以进入停⽌状态，不再接收输⼊。在程序退出前，OpenGL总会先停⽌工作。</strong></li>
</ul>
<h3 id="渲染rendering">渲染（Rendering）</h3>
<p>将图形/图像数据转换成3D空间图像操作叫做渲染。</p>
<h3 id="顶点数组vertexarray和顶点缓冲区vertexbuffer">顶点数组(VertexArray)和顶点缓冲区(VertexBuffer)</h3>
<ul>
<li>画图⼀般是先画好图像的骨架，然后再往⻣架⾥面填充颜⾊，这对于OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，<strong>OpenGL中的图像都是由图元组成</strong>。在OpenGL中，常用的图元类型是:<strong>点、线、三⻆形</strong>。</li>
<li>开发者可以选择设定函数指针，在调⽤绘制方法的时候，直接由内存传⼊入顶点数据，也就是说<strong>这部分数据之前是存储在内存当中的，被称为顶点数组</strong>。</li>
<li>性能更⾼的做法是，提前分配⼀块显存，<strong>将顶点数据预先传入到显存当中</strong>。这部分的显存，就被称为<strong>顶点缓冲区</strong>。</li>
<li>顶点指的是我们在绘制一个图形时,<strong>它的顶点位置数据</strong>。而这个数据可以直接<strong>存储在数组中或者将其缓存到GPU内存中</strong>。</li>
</ul>
<h3 id="管线">管线</h3>
<ul>
<li>渲染管线也称为渲染流水线，是显示芯片内部处理图形信号相互独立的并行处理单元</li>
<li>在OpenGL下渲染图形,就会经历⼀个一个节点，而这样的操作可以理解为管线。大家可以想象成流水线，<strong>每个任务类似流水线般执行，任务之间有先后顺序</strong>。流水线是为了提高产品的生产能力和效率，而渲染管线则是<strong>提高显卡的工作能力和效率</strong>。</li>
<li>管线是一个抽象的概念，之所以称之为管线是因为<strong>显卡在处理数据的时候是按照⼀个固定的顺序来的，⽽且严格按照这个顺序</strong>。就像⽔从⼀根管⼦子的一端流到另一端，这个顺序是不能打破的。</li>
<li>管线分为固定管线和可编程管线:</li>
</ul>
<h3 id="固定管线存储着色器">固定管线/存储着色器</h3>
<p>固定管线是不需要也不允许你自己去定义顶点渲染和像素渲染的具体逻辑，它<strong>内部已经固化了一套完整的渲染流程</strong>。类似于iOS开发中会封装很多API,而我们只需要调⽤,就可以实现功能.不需要关注底层实现原理。</p>
<h3 id="可编程管线">可编程管线</h3>
<ul>
<li>由于OpenGL的使⽤用场景⾮常丰富,固定管线或存储着⾊色器⽆法完成每⼀个业务,这时将相关部分开放成可编程。</li>
<li>可编程管线是将<strong>固定函数渲染流水线</strong>以可编程的方式实现，在这些具体的步骤中运行自己定义的函数，这样可以灵活的扩展图形渲染流水线的功能</li>
</ul>
<h3 id="着色器程序shader">着色器程序(Shader)</h3>
<ul>
<li>OpenGL在实际调⽤绘制函数之前，还需要指定⼀个由shader编译成的着⾊器程序。</li>
<li>常⻅的着⾊器主要有<strong>顶点着⾊器(VertexShader)，⽚段着⾊器(FragmentShader)/像素着色器(PixelShader)，⼏何着色器(GeometryShader)，曲面细分着⾊器(TessellationShader)</strong>。⽚段着⾊器和像素着⾊器只是在OpenGL和DX中的不同叫法⽽而已。可惜的是，直到OpenGLES 3.0，依然只支持了顶点着⾊器和⽚段着⾊器这两个最基础的着⾊器。</li>
<li>OpenGL在处理shader时，和其他编译器一样。（这个流程后面会重点介绍，这里先只做简单介绍）</li>
</ul>
<ol>
<li><strong>通过编译、链接等步骤，⽣成了着⾊器程序(glProgram)</strong>，着色器程序同时包含了顶点着⾊器和⽚段着⾊器的运算逻辑。</li>
<li>在OpenGL进⾏绘制的时候，⾸先由顶点着⾊器<strong>对传⼊的顶点数据进⾏运算</strong>。再通过<strong>图元装配，将顶点转换为图元</strong>。</li>
<li>然后进行<strong>光栅化</strong>，将图元这种⽮量图形，<strong>转换为栅格化数据</strong>。</li>
<li>最后，<strong>将栅格化数据传⼊片段着⾊器中进行运算</strong>。⽚段着⾊器会对栅格化数据中的<strong>每⼀个像素进行运算，并决定像素的颜⾊</strong>。</li>
</ol>
<h3 id="顶点着色器">顶点着色器</h3>
<ul>
<li>⼀般⽤来处理图形每个<strong>顶点变换(旋转/平移/投影等)</strong>。</li>
<li>顶点着⾊器是OpenGL中⽤于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说<strong>每个顶点数据都会执行⼀次顶点着⾊器</strong>，当然这是<strong>并行</strong>的，并且顶点着⾊器运算过程中<strong>无法访问其他顶点的数据</strong>。</li>
<li>⼀般来说典型的需要计算的顶点属性主要包括<strong>顶点坐标变换、逐顶点光照运算</strong>等等。顶点坐标<strong>由⾃身坐标系转换到归⼀化坐标系</strong>的运算，就是在这里发⽣的。</li>
</ul>
<h3 id="片元着色器">片元着色器</h3>
<ul>
<li>⼀般⽤用来处理图形中<strong>每个像素点颜色计算和填充</strong>。</li>
<li>⽚段着⾊器是OpenGL中⽤用于<strong>计算⽚段(像素)颜色</strong>的程序。⽚段着⾊器是逐像素运算的程序，也就是说<strong>每个像素都会执⾏一次⽚段着⾊器</strong>，当然也是并行的。</li>
</ul>
<h3 id="glsl">GLSL</h3>
<ul>
<li><strong>OpenGL着⾊语言(OpenGL Shading Language）</strong>，是⽤来在OpenGL中着⾊编程的语言，也即开发人员写的短小的⾃定义程序。</li>
<li>他们是在图形卡的**GPU(Graphic Processor Unit图形处理单元)**上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。⽐如:视图转换、投影转换等。</li>
<li>GLSL(GL Shading Language)的着⾊器代码分成2个部分:<strong>Vertex Shader(顶点着⾊器)和Fragment(⽚断着⾊器，也叫片元着色器）</strong>。</li>
</ul>
<h3 id="光栅化rasterization">光栅化（Rasterization）</h3>
<ul>
<li>是<strong>把顶点数据转换为片元</strong>的过程，具有将图转化为⼀个栅格组成的图象的作用，特点是<strong>每个元素对应帧缓冲区中的⼀像素</strong>。</li>
<li>其实是一种<strong>将⼏何图元变为⼆维图像的过程</strong>。该过程包含了两部分的工作。第一部分⼯作:<strong>决定窗⼝坐标中的哪些整型栅格区域被基本图元占用</strong>;第⼆部分⼯作:<strong>分配⼀个颜⾊值和⼀个深度值到各个区域。光栅化过程产⽣的是⽚元</strong>。</li>
<li>把物体的数学描述以及与物体相关的颜色信息<strong>转换为屏幕上用于对应位置的像素及用于填充像素的颜色</strong>，这个过程称为光栅化，这是⼀个<strong>将模拟信号转化为离散信号的过程</strong>。</li>
</ul>
<p>如下图就是光栅化的过程的一种理解，第一步告诉计算机我要显示一个<strong>圆形</strong>，第二步计算机把这个圆形转换成可以显示的像素点<br>
<img src="https://user-gold-cdn.xitu.io/2019/12/10/16eebc9b67a5c822?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片"></p>
<h3 id="着色">着色</h3>
<p>沿着顶点之间改变颜色值，能轻松创建光照射到一个立方体的效果。</p>
<h3 id="纹理">纹理</h3>
<p>纹理可以理解为图⽚。⼤家在渲染图形时<strong>需要在其编码填充图片</strong>，为了<strong>使得场景更加逼真</strong>，⽽这⾥使⽤的图⽚,就是常说的<strong>纹理</strong>。但是在OpenGL中,我们更加习惯叫纹理,而不是图片。如一面墙，在它上面铺的墙纸就是纹理。</p>
<h3 id="纹理贴图">纹理贴图</h3>
<p>将纹理图片附着到你绘图的图像上</p>
<h3 id="混合">混合</h3>
<p>其实就是颜色混合的效果。在测试阶段之后，如果像素依然没有被剔除，那么<strong>像素的颜色将会和帧缓冲区中颜色附着上的颜⾊进行混合</strong>，混合的算法可以通过OpenGL的函数进⾏指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合算法，⼀般可以<strong>通过像素着⾊器进⾏实现</strong>，当然性能会⽐原⽣的混合算法差一些。</p>
<h3 id="渲染上屏交换缓冲区swapbuffer">渲染上屏/交换缓冲区(SwapBuffer)</h3>
<ul>
<li>渲染缓冲区⼀般映射的是系统的资源⽐如窗⼝。如果<strong>将图像直接渲染到窗⼝对应的渲染缓冲区</strong>，则可以将图像显示到屏幕上。</li>
<li>但是，值得注意的是，如果每个窗⼝只有⼀个缓冲区，那么在绘制过程中屏幕进行了刷新，窗⼝可能显示出不完整的图像。</li>
<li>为了解决这个问题，常规的OpenGL程序<strong>⾄少都会有两个缓冲区</strong>。显示在屏幕上的称为<strong>屏幕缓冲区</strong>，没有显示的称为<strong>离屏缓冲区</strong>。在⼀个缓冲区渲染完成之后，通过<strong>将屏幕缓冲区和离屏缓冲区交换</strong>，实现图像在屏幕上的显示。</li>
<li>由于<strong>显示器的刷新⼀般是逐⾏进行的</strong>，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，<strong>因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进⾏交换</strong>，这个信号就被称为<strong>垂直同步信号</strong>，这个技术被称为<strong>垂直同步</strong>。</li>
<li>使⽤了<strong>双缓冲区和垂直同步技术</strong>之后，由于总是要等待缓冲区交换之后再进⾏下⼀帧的渲染，使得帧率⽆法完全达到硬件允许的最⾼⽔平。为了解决这个问题，引⼊了<strong>三缓冲区技术</strong>，在等待垂直同步时，<strong>来回交替渲染两个离屏的缓冲区</strong>，⽽垂直同步发生时，<strong>屏幕缓冲区和最近渲染完成的离屏缓冲区交换</strong>，实现充分利⽤硬件性能的⽬的。</li>
</ul>
<h3 id="变换矩阵transformation">变换矩阵(Transformation)</h3>
<p>例如图形想发⽣平移,缩放,旋转变换.就需要使⽤变换矩阵.</p>
<h3 id="投影矩阵projection">投影矩阵(Projection)</h3>
<p>用于将3D坐标转换为⼆维屏幕坐标,实际线条也将在⼆维坐标下进⾏绘制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sign In with Apple 使用苹果账号登录你的应用]]></title>
        <id>http://localhost:4000/post/de-feng-ge-ba</id>
        <link href="http://localhost:4000/post/de-feng-ge-ba">
        </link>
        <updated>2019-11-26T07:11:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>苹果在 9 月 12 号更新了审核指南，加入 4.8 Sign in with Apple 一条，要求所有使用 第三方登录 的 App，都 必须接入 Sign in with Apple。符合以下条件的 App，可以不接入：</p>
</blockquote>
<blockquote>
<p>• 使用自建账户和登录系统；</p>
</blockquote>
<blockquote>
<p>• 要求用户使用现有的教育或企业账户登录的教育、企业或商业类应用；</p>
</blockquote>
<blockquote>
<p>• 使用政府或行业支持的公民身份识别系统或电子 ID 来验证用户；</p>
</blockquote>
<blockquote>
<p>• 应用特定于第三方服务，用户需要使用邮箱、社交媒体或其它第三方账户才能访问其内容的应用；</p>
</blockquote>
<blockquote>
<p>已经上架的 App 需在 2020 年 4 月 前完成接入工作，新上架 App（如果支持三方登录）必须接入，负责将被拒。</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>对于绝大部分应用，通常都会有自己的账号体系，但为了避免用户经常忘记账号密码，那些中小型 App 一般都会接入来自大厂的第三方登录 SDK，如在国外常见的有使用 Google、Facebook、Twitter、GitHub 等账号登录；而在国内，近两年几乎所有的 App 都会推荐首先使用手机号+短信验证码的方式注册/登录，同时也会接入像微信、QQ、微博、支付宝等超级 App 的登录 SDK，便于用户实现一键登录，如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqymx7FxQjG0KRH7reHYGnI9SI2FCflyUmiam3PraqJeD1Cr6nlAEEOTQ/640?wx_fmt=jpeg" alt="图片"></figure>
<p>在 WWDC 2019 上，苹果也想在第三方登录服务这块“蛋糕”上分一杯羹，给我们带来了 “Sign In with Apple”（使用苹果账号登录）。这似乎也是水到渠成的事，因为几乎所有的 iOS/macOS 设备都会登录 Apple ID，而且近两年来，苹果强制对所有的 Apple ID 推行 Two-Factor Authentication（2FA，双重因子验证），大大提高了苹果账号的安全性，减少了盗号风险。</p>
<p>因此，我们可以畅想在不久的将来，在苹果设备上，只要登录了 Apple ID，就可以直接登录所有的 App，是不是很方便？但这同时也是黑客们的福音啊...?</p>
<ol>
<li>概览<br>
<code>The fast, easy way to sign in to apps and websites.</code></li>
</ol>
<p>通过 Sign In with Apple，用户可以轻松登录开发者的应用和网站，开发者可以获取到以下三个信息用于创建自己的账号体系（下一节会细讲）：</p>
<p>ID</p>
<p>Full name</p>
<p>Verified email address</p>
<p>它具有如下几个特性，详见这里：</p>
<p>简化账号的创建和登录流程，无缝跨设备使用；</p>
<p>开发者可以获取到已验证过的邮箱作为登录账号或者与用户进行通信（注：用户可以选择隐藏真实邮箱，并使用苹果提供的虚拟邮箱进行授权）；</p>
<figure data-type="image" tabindex="2"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpq4Kse6ib6Mw1Cx0IGib46uMiaNUSnZue46Nw9iabezdhQdaRfDIMYPLeXXw/640?wx_fmt=jpeg" alt="图片"></figure>
<p>系统内置的安全性：2FA 双重验证（Face ID 或 Touch ID），从此登录不再需要密码；</p>
<p>尊重用户隐私：开发者仅仅可获取到用户的姓名和邮箱，同时苹果不会收集任何用户与应用之间使用数据；</p>
<p>反欺诈：使用设备上的机器学习等技术和其他信息，帮助开发者判断一个账号是否为真实用户；</p>
<p>最重要的是，它是跨平台的！！！</p>
<figure data-type="image" tabindex="3"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqBTHzcMPBQDKFwhIicImHqiaKeBJ6Ct2uxDfFO6pmPNMUib0eYhXQYFIKA/640?wx_fmt=jpeg" alt=""></figure>
<ol start="3">
<li>如何集成<br>
在你的 App 中集成 “Sign In with Apple” 服务，大致只需要以下 4 步骤：</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqk1US6DSISpnKKSyUqNHcsdQT0txnmqIdS6vHO6MPicomNZHD7DyRvmw/640?wx_fmt=jpeg" alt=""></figure>
<p>4.1 添加登录按钮<br>
首先，在你 App 的登录页面添加一个 “Sign In with Apple” 按钮 ASAuthorizationAppleIDButton，并添加按钮点击响应事件，代码大致如下：</p>
<pre><code>// Add “Sign In with Apple” button to your login viewfunc setupProviderLoginView() {
    let authorizationButton = ASAuthorizationAppleIDButton()authorizationButton.addTarget(self, action: #selector(handleAuthorizationAppleIDButtonPress), for: .touchUpInside)self.loginProviderStackView.addArrangedSubview(authorizationButton)
    }
</code></pre>
<p>当然你也可以自定义苹果登录按钮的样式，样式要求详见这个文档：Human Interface Guidelines</p>
<p>最终的登录页面效果图参考如下：</p>
<figure data-type="image" tabindex="5"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpq8zI2zEzXHibl7DibJ4R35fqleNn11iaBMQuhmZJ14W7oDb053qBIXwkaw/640?wx_fmt=jpeg" alt=""></figure>
<p>4.2 发起授权请求<br>
在上述按钮点击事件 handleAuthorizationAppleIDButtonPress 中配置需要获取的数据权限范围（例如：用户名、邮箱等），然后设置回调代理，并发起登录授权请求，代码如下：</p>
<p>// Configure request, setup delegates and perform authorization request@objc func handleAuthorizationAppleIDButtonPress() {let appleIDProvider = ASAuthorizationAppleIDProvider()let request = appleIDProvider.createRequest()request.requestedScopes = [.fullName, .email]let authorizationController = ASAuthorizationController(authorizationRequests: [request])authorizationController.delegate = selfauthorizationController.presentationContextProvider = selfauthorizationController.performRequests()}<br>
当用户点击 “Sign In with Apple” 按钮后，就会显示苹果登录授权确认页面，如下图所示：</p>
<figure data-type="image" tabindex="6"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqPV590b0dmBEhyTSr9zMJtZia4PhmtItmgtxicyLGgZBibgskkEamibU0nA/640?wx_fmt=jpeg" alt=""></figure>
<p>在该页面，用户可以选择是否给你返回他的名字和真实邮箱，当然用户也可以选择隐藏自己的邮箱，此时开发者会得到一个虚拟的用户邮箱地址（此邮箱收到的邮件会转发到用户真实的邮箱上）。当用户点击 “Continue” 按钮后，会进行 “Touch ID” 或者 “Face ID” 双重验证，然后回调数据给开发者。</p>
<p>4.3 处理回调，服务端验证结果<br>
我们需要在代码中实现两个代理回调 ASAuthorizationControllerDelegate、ASAuthorizationControllerPresentationContextProviding 分别用于处理授权登录成功和失败、以及提供用于展示授权页面的 Window，代码如下：</p>
<p>/// MARK: ASAuthorizationControllerDelegatefunc authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {if let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential {let userIdentifier = appleIDCredential.userlet fullName = appleIDCredential.fullNamelet email = appleIDCredential.emaillet realUserStatus = credential.realUserStatuslet identityToken = credential.identityTokenlet authCode = credential.authorizationCode// Create account in your system}}func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {// Handle error.}/// MARK: ASAuthorizationControllerPresentationContextProvidingfunc presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor {return self.view.window!}<br>
在授权成功回调中，我们可以拿到以下几类数据：</p>
<p>User ID: Unique, stable, team-scoped user ID，苹果用户唯一标识符，该值在同一个开发者账号下的所有 App 下是一样的，开发者可以用该唯一标识符与自己后台系统的账号体系绑定起来（这与国内的微信、QQ、微博等第三方登录流程基本一致）。</p>
<p>Verification data: Identity token, code，验证数据，用于传给开发者后台服务器，然后开发者服务器再向苹果的身份验证服务端验证本次授权登录请求数据的有效性和真实性，详见 Sign In with Apple REST API。如果验证成功，可以根据 userIdentifier 判断账号是否已存在，若存在，则返回自己账号系统的登录态，若不存在，则创建一个新的账号，并返回对应的登录态给 App。</p>
<p>Account information: Name, verified email，苹果用户信息，包括全名、邮箱等。</p>
<p>Real user indicator: High confidence indicator that likely real user，用于判断当前登录的苹果账号是否是一个真实用户，取值有：unsupported、unknown、likelyReal。</p>
<p>4.4 处理苹果账号会话发生变化<br>
当开发者的 App 通过苹果账号登录后，iOS/macOS 设备上登录的 Apple ID 发生变化时，例如：</p>
<p>设备上的 Apple ID 退出登录、切换新的账号登录；</p>
<p>用户在设置页面禁止 App 使用苹果账号登录，如下图：</p>
<figure data-type="image" tabindex="7"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqAjc5ChXHrTGILickCZ1njuE80yE8LILib4ib3nEsGWicv3YnAKPmWyW5SQ/640?wx_fmt=jpeg" alt=""></figure>
<p>此时，也需要通知到 App 做账号登出处理。因此，我们可以 App 启动时，调用 ASAuthorizationAppleIDProvider 的 getCredentialState 方法，传入当前用户的 UserIdentifier 进行判断：</p>
<p>let appleIDProvider = ASAuthorizationAppleIDProvider()appleIDProvider.getCredentialState(forUserID: &quot;currentUserIdentifier&quot;) { (credentialState, error) inswitch credentialState {case .authorized:// The Apple ID credential is validbreakcase .revoked:// Apple ID Credential revoked, handle unlinkbreakcase .notFound:// Credential not found, show login UIbreakdefault:break}}<br>
苹果称，该 API 的速度非常快，我们可以在 App 每次启动时调用，然后根据结果做相应的处理：</p>
<p>authorized：登录状态有效；</p>
<p>revoked：上次使用苹果账号登录的凭据已被移除，需退出解除绑定并重新引导使用苹果登录；</p>
<p>notFound：未登录，直接显示开发者 App 的登录页面。</p>
<p>此外，苹果也提供了通知的方式来监听，在 App 使用过程中，当苹果账号发生变化时做相应的处理：</p>
<p>// Register for revocation notificationlet center = NotificationCenter.defaultlet name = NSNotification.Name.ASAuthorizationAppleIDProviderCredentialRevokedlet observer = center.addObserver(forName: name, object: nil, queue: nil) { (Notification) in// Sign the user out, optionally guide them to sign in again}<br>
4.5 快速登录已有账户<br>
如果一个 Apple ID 之前已在 App 中授权登录过了，此时点击 “Sign In with Apple” 会直接显示如下页面：</p>
<figure data-type="image" tabindex="8"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqYx4iacGmILpeeFabdr3pT1BkjicRclPzRBtu4niaHEM6J2b4xgpL0SsibA/640?wx_fmt=jpeg" alt=""></figure>
<p>或者 App 上次用自己的账号/密码登录后保存在 Keychain 中，此时可以在登录页面直接请求读取密码进行自动填充：</p>
<figure data-type="image" tabindex="9"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpq8g3jtgCh2uYJicM9jkETsDWEiaRQp5EbPlkdWZtkW5n7mHwnlSAgEWSw/640?wx_fmt=jpeg" alt=""></figure>
<p>对于读取 Keychain 中保存的密码，苹果提供了与授权登录类似的 API，我们可以在登录页面的 viewDidAppear 方法中执行代码如下：</p>
<p>/// Prompts the user if an existing iCloud Keychain credential or Apple ID credential is found.func performExistingAccountSetupFlows() {// Prepare requests for both Apple ID and password providers.let requests = [ASAuthorizationAppleIDProvider().createRequest(),ASAuthorizationPasswordProvider().createRequest()]// Create an authorization controller with the given requests.let authorizationController = ASAuthorizationController(authorizationRequests: requests)authorizationController.delegate = selfauthorizationController.presentationContextProvider = selfauthorizationController.performRequests()}<br>
然后在回调方法中进行判断：</p>
<p>func authorizationController(controller _: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {switch authorization.credential {case let credential as ASAuthorizationAppleIDCredential:let userIdentifier = credential.user// Sign the user in using the Apple ID credentialcase let credential as ASPasswordCredential:// Sign the user in using their existing password credentialdefault: break}}</p>
<h2 id="补充">补充</h2>
<p>App 要集成苹果账号登录，必须在 Xcode 工程的 Signing &amp; Capabilities tab 中添加 “Sign In with Apple” 能力，需登录相应的开发者账号；</p>
<p>调试时，必须使用运行最新系统版本的真机设备，且设备上登录的 Apple ID 必须开启 2FA 双重验证；</p>
<p>上述示例代码完整的 Demo，详见这里：Adding the Sign In with Apple Flow to Your App</p>
<ol start="4">
<li>跨平台 - JavaScript SDK<br>
“Sign In with Apple” 最大的杀手锏在于跨平台，除了苹果自己生态内的系统，苹果还提供了 JavaScript SDK，使得在 Web 应用中也能很方便地使用该服务。因为 Web 本身是跨平台的，所以理论上在 Windows 或者 Android 操作系统上也可以使用苹果账号登录啦~</li>
</ol>
<p>iOS, macOS, tvOS, and watchOS: Native API</p>
<p>Web / Windows / Android: Javascript SDK</p>
<figure data-type="image" tabindex="10"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpquShibE2FpLn98SuCiaI4IAKG23xgRibicT5jvP9GgiaM7l4AzEbOWK4wS4g/640?wx_fmt=jpeg" alt=""></figure>
<p>它具有如下 3 个特性：</p>
<p>Simple browser-based login：点击 Web 页面上的苹果登录按钮，跳转到苹果网站进行登录，然后苹果会把登录结果回调给开发者填写的 redirectUri；</p>
<p>Similar to native API：JS API 与原生 API 类似，简单易用；</p>
<p>Native experience when using Safari：如果用户使用 Safari 浏览器访问 Web，则会默认调用 Native API 进行授权登录操作；</p>
<p>JavaScript SDK 的使用步骤大致如下：</p>
<p>Include：引入 SDK 依赖</p>
<p><code>&lt;script src=&quot;https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js&quot;&gt;</code><br>
Button：添加苹果登录按钮，并自定义样式</p>
<p><code>&lt;div id=&quot;appleid-signin&quot;&gt;&lt;/div&gt;</code><br>
Configure：登录信息配置，设置回调 URL</p>
<p><code>AppleID.auth.init({clientId : 'com.example.webapp',scope : 'name email',redirectURI : 'https://example.com/redirectUri',state : 'state'});</code><br>
Result：服务端处理登录回调结果</p>
<p><code>POST /redirectUri</code><br>
关于苹果登录的 JS SDK 更详细的内容，请参考这里：Sign In with Apple JS</p>
<ol start="5">
<li>App Store 审核<br>
在最近更新的苹果应用商店审核指南 Updates to the App Store Review Guidelines 中，有如下一段话：</li>
</ol>
<blockquote>
<p>We’ve updated the App Store Review Guidelines to provide criteria for when apps are required to use Sign in with Apple. Starting today, new apps submitted to the App Store must follow these guidelines. Existing apps and app updates must follow them by April 2020. We’ve also provided new guidelines for using Sign in with Apple on the web and other platforms.</p>
</blockquote>
<p>也就是说，所有已接入其它第三方登录的 App 也必须在 2020 年 4 月前完成接入工作，而新上架提交的 App 必须完成接入工作，否则可能就不给过（当然，那些只有自己账号体系登录的 App 就不用担心了），苹果爸爸还真是强势，所以，适配工作赶快行动起来吧~</p>
]]></content>
    </entry>
</feed>