<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OpenGL入门（一) —— OpenGL专业名词解析 | 杨立鹏的个人博客</title>
<meta name="description" content="不积跬步无以至千里，不积小流无以成江海！" />
<link rel="shortcut icon" href="https://alanyangcn.github.io//favicon.ico?v=1589939966678">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://alanyangcn.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://alanyangcn.github.io/">
  <img class="avatar" src="https://alanyangcn.github.io//images/avatar.png?v=1589939966678" alt="">
  </a>
  <h1 class="site-title">
    杨立鹏的个人博客
  </h1>
  <p class="site-description">
    不积跬步无以至千里，不积小流无以成江海！
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              OpenGL入门（一) —— OpenGL专业名词解析
            </h2>
            <div class="post-info">
              <span>
                2019-12-11
              </span>
              <span>
                11 min read
              </span>
              
                <a href="https://alanyangcn.github.io/tag/nhwfLq6tQ/" class="post-tag">
                  # OpenGL
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://user-gold-cdn.xitu.io/2019/12/10/16eebc9b64c41929?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="opengl">OpenGL</h3>
<p><strong>OpenGL(Open Graphics Library)</strong> 是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。<br>
<strong>OpengGL ES(OpenGL for Embedded Systems)</strong> 是OpenGL的一个子集，针对手机、pad、游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。</p>
<h3 id="上下文context">上下文Context</h3>
<ul>
<li>
<p>在应用程序调用任何OpenGL的指令之前，需要安排⾸先创建⼀个OpenGL的 上下文。这个上下文是⼀个⾮常庞⼤的状态机，<strong>保存了OpenGL中的各种状态</strong>，这也是OpenGL指令执行的基础。</p>
</li>
<li>
<p>OpenGL的函数不管在哪个语⾔中，都是类似C语言⼀样的⾯向过程的函数，本质上都是<strong>对OpenGL上下文这个庞⼤的状态机中的某个状态或者对象进行操作</strong>，当然你得⾸先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调用封装成为⼀个⾯向对象的 图形API的。</p>
</li>
<li>
<p>由于OpenGL上下文是⼀个巨⼤的状态机，<strong>切换上下文往会产生较⼤的开销，但是不同的绘制模块，可能需要使⽤完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源</strong>。这样的方案，会⽐反复切换上下⽂，或者⼤量修改渲染状态，更加合理高效的。</p>
</li>
</ul>
<h3 id="状态机">状态机</h3>
<p>状态机是理论上的⼀种机器，这个非常难以理解。所以我们可以这么理解: 状态机描述了一个对象在其生命周期内所经历的各种状态，状态间的转变，发生转变的动因，条件及转变中所执行的活动。或者说状态机是一种行为，说明对象在其⽣命周期中响应事件所经历的状态序列以及对那些状态事件的响应。因此具有以下特点:</p>
<ul>
<li>有记忆功能，能<strong>记住其当前的状态</strong></li>
<li><strong>可以接收输入</strong>，根据输入的内容和⾃己的原先状态，修改⾃己当前状态，并且可以有对应输出</li>
<li>当进⼊**特殊状态(停机状态)**的时候，便不再接收输入，停⽌工作</li>
</ul>
<p>在OpenGL中，状态机的表现如下:</p>
<ul>
<li><strong>OpenGL可以记录⾃己的状态(如当前所使用的颜色、是否开启了深度测试、是否开启了混合功能等)</strong></li>
<li><strong>OpenGL可以接收输⼊(当调⽤OpenGL函数的时候，实际上可以看成 OpenGL在接收我们的输入)</strong>。如我们调用<span style="color:red">glColor3f</span>，则OpenGL接收到这个输⼊后会修改⾃己的“当前颜色”这个状态;</li>
<li><strong>OpenGL可以进入停⽌状态，不再接收输⼊。在程序退出前，OpenGL总会先停⽌工作。</strong></li>
</ul>
<h3 id="渲染rendering">渲染（Rendering）</h3>
<p>将图形/图像数据转换成3D空间图像操作叫做渲染。</p>
<h3 id="顶点数组vertexarray和顶点缓冲区vertexbuffer">顶点数组(VertexArray)和顶点缓冲区(VertexBuffer)</h3>
<ul>
<li>画图⼀般是先画好图像的骨架，然后再往⻣架⾥面填充颜⾊，这对于OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，<strong>OpenGL中的图像都是由图元组成</strong>。在OpenGL中，常用的图元类型是:<strong>点、线、三⻆形</strong>。</li>
<li>开发者可以选择设定函数指针，在调⽤绘制方法的时候，直接由内存传⼊入顶点数据，也就是说<strong>这部分数据之前是存储在内存当中的，被称为顶点数组</strong>。</li>
<li>性能更⾼的做法是，提前分配⼀块显存，<strong>将顶点数据预先传入到显存当中</strong>。这部分的显存，就被称为<strong>顶点缓冲区</strong>。</li>
<li>顶点指的是我们在绘制一个图形时,<strong>它的顶点位置数据</strong>。而这个数据可以直接<strong>存储在数组中或者将其缓存到GPU内存中</strong>。</li>
</ul>
<h3 id="管线">管线</h3>
<ul>
<li>渲染管线也称为渲染流水线，是显示芯片内部处理图形信号相互独立的并行处理单元</li>
<li>在OpenGL下渲染图形,就会经历⼀个一个节点，而这样的操作可以理解为管线。大家可以想象成流水线，<strong>每个任务类似流水线般执行，任务之间有先后顺序</strong>。流水线是为了提高产品的生产能力和效率，而渲染管线则是<strong>提高显卡的工作能力和效率</strong>。</li>
<li>管线是一个抽象的概念，之所以称之为管线是因为<strong>显卡在处理数据的时候是按照⼀个固定的顺序来的，⽽且严格按照这个顺序</strong>。就像⽔从⼀根管⼦子的一端流到另一端，这个顺序是不能打破的。</li>
<li>管线分为固定管线和可编程管线:</li>
</ul>
<h3 id="固定管线存储着色器">固定管线/存储着色器</h3>
<p>固定管线是不需要也不允许你自己去定义顶点渲染和像素渲染的具体逻辑，它<strong>内部已经固化了一套完整的渲染流程</strong>。类似于iOS开发中会封装很多API,而我们只需要调⽤,就可以实现功能.不需要关注底层实现原理。</p>
<h3 id="可编程管线">可编程管线</h3>
<ul>
<li>由于OpenGL的使⽤用场景⾮常丰富,固定管线或存储着⾊色器⽆法完成每⼀个业务,这时将相关部分开放成可编程。</li>
<li>可编程管线是将<strong>固定函数渲染流水线</strong>以可编程的方式实现，在这些具体的步骤中运行自己定义的函数，这样可以灵活的扩展图形渲染流水线的功能</li>
</ul>
<h3 id="着色器程序shader">着色器程序(Shader)</h3>
<ul>
<li>OpenGL在实际调⽤绘制函数之前，还需要指定⼀个由shader编译成的着⾊器程序。</li>
<li>常⻅的着⾊器主要有<strong>顶点着⾊器(VertexShader)，⽚段着⾊器(FragmentShader)/像素着色器(PixelShader)，⼏何着色器(GeometryShader)，曲面细分着⾊器(TessellationShader)</strong>。⽚段着⾊器和像素着⾊器只是在OpenGL和DX中的不同叫法⽽而已。可惜的是，直到OpenGLES 3.0，依然只支持了顶点着⾊器和⽚段着⾊器这两个最基础的着⾊器。</li>
<li>OpenGL在处理shader时，和其他编译器一样。（这个流程后面会重点介绍，这里先只做简单介绍）</li>
</ul>
<ol>
<li><strong>通过编译、链接等步骤，⽣成了着⾊器程序(glProgram)</strong>，着色器程序同时包含了顶点着⾊器和⽚段着⾊器的运算逻辑。</li>
<li>在OpenGL进⾏绘制的时候，⾸先由顶点着⾊器<strong>对传⼊的顶点数据进⾏运算</strong>。再通过<strong>图元装配，将顶点转换为图元</strong>。</li>
<li>然后进行<strong>光栅化</strong>，将图元这种⽮量图形，<strong>转换为栅格化数据</strong>。</li>
<li>最后，<strong>将栅格化数据传⼊片段着⾊器中进行运算</strong>。⽚段着⾊器会对栅格化数据中的<strong>每⼀个像素进行运算，并决定像素的颜⾊</strong>。</li>
</ol>
<h3 id="顶点着色器">顶点着色器</h3>
<ul>
<li>⼀般⽤来处理图形每个<strong>顶点变换(旋转/平移/投影等)</strong>。</li>
<li>顶点着⾊器是OpenGL中⽤于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说<strong>每个顶点数据都会执行⼀次顶点着⾊器</strong>，当然这是<strong>并行</strong>的，并且顶点着⾊器运算过程中<strong>无法访问其他顶点的数据</strong>。</li>
<li>⼀般来说典型的需要计算的顶点属性主要包括<strong>顶点坐标变换、逐顶点光照运算</strong>等等。顶点坐标<strong>由⾃身坐标系转换到归⼀化坐标系</strong>的运算，就是在这里发⽣的。</li>
</ul>
<h3 id="片元着色器">片元着色器</h3>
<ul>
<li>⼀般⽤用来处理图形中<strong>每个像素点颜色计算和填充</strong>。</li>
<li>⽚段着⾊器是OpenGL中⽤用于<strong>计算⽚段(像素)颜色</strong>的程序。⽚段着⾊器是逐像素运算的程序，也就是说<strong>每个像素都会执⾏一次⽚段着⾊器</strong>，当然也是并行的。</li>
</ul>
<h3 id="glsl">GLSL</h3>
<ul>
<li><strong>OpenGL着⾊语言(OpenGL Shading Language）</strong>，是⽤来在OpenGL中着⾊编程的语言，也即开发人员写的短小的⾃定义程序。</li>
<li>他们是在图形卡的**GPU(Graphic Processor Unit图形处理单元)**上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。⽐如:视图转换、投影转换等。</li>
<li>GLSL(GL Shading Language)的着⾊器代码分成2个部分:<strong>Vertex Shader(顶点着⾊器)和Fragment(⽚断着⾊器，也叫片元着色器）</strong>。</li>
</ul>
<h3 id="光栅化rasterization">光栅化（Rasterization）</h3>
<ul>
<li>是<strong>把顶点数据转换为片元</strong>的过程，具有将图转化为⼀个栅格组成的图象的作用，特点是<strong>每个元素对应帧缓冲区中的⼀像素</strong>。</li>
<li>其实是一种<strong>将⼏何图元变为⼆维图像的过程</strong>。该过程包含了两部分的工作。第一部分⼯作:<strong>决定窗⼝坐标中的哪些整型栅格区域被基本图元占用</strong>;第⼆部分⼯作:<strong>分配⼀个颜⾊值和⼀个深度值到各个区域。光栅化过程产⽣的是⽚元</strong>。</li>
<li>把物体的数学描述以及与物体相关的颜色信息<strong>转换为屏幕上用于对应位置的像素及用于填充像素的颜色</strong>，这个过程称为光栅化，这是⼀个<strong>将模拟信号转化为离散信号的过程</strong>。</li>
</ul>
<p>如下图就是光栅化的过程的一种理解，第一步告诉计算机我要显示一个<strong>圆形</strong>，第二步计算机把这个圆形转换成可以显示的像素点<br>
<img src="https://user-gold-cdn.xitu.io/2019/12/10/16eebc9b67a5c822?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片" loading="lazy"></p>
<h3 id="着色">着色</h3>
<p>沿着顶点之间改变颜色值，能轻松创建光照射到一个立方体的效果。</p>
<h3 id="纹理">纹理</h3>
<p>纹理可以理解为图⽚。⼤家在渲染图形时<strong>需要在其编码填充图片</strong>，为了<strong>使得场景更加逼真</strong>，⽽这⾥使⽤的图⽚,就是常说的<strong>纹理</strong>。但是在OpenGL中,我们更加习惯叫纹理,而不是图片。如一面墙，在它上面铺的墙纸就是纹理。</p>
<h3 id="纹理贴图">纹理贴图</h3>
<p>将纹理图片附着到你绘图的图像上</p>
<h3 id="混合">混合</h3>
<p>其实就是颜色混合的效果。在测试阶段之后，如果像素依然没有被剔除，那么<strong>像素的颜色将会和帧缓冲区中颜色附着上的颜⾊进行混合</strong>，混合的算法可以通过OpenGL的函数进⾏指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合算法，⼀般可以<strong>通过像素着⾊器进⾏实现</strong>，当然性能会⽐原⽣的混合算法差一些。</p>
<h3 id="渲染上屏交换缓冲区swapbuffer">渲染上屏/交换缓冲区(SwapBuffer)</h3>
<ul>
<li>渲染缓冲区⼀般映射的是系统的资源⽐如窗⼝。如果<strong>将图像直接渲染到窗⼝对应的渲染缓冲区</strong>，则可以将图像显示到屏幕上。</li>
<li>但是，值得注意的是，如果每个窗⼝只有⼀个缓冲区，那么在绘制过程中屏幕进行了刷新，窗⼝可能显示出不完整的图像。</li>
<li>为了解决这个问题，常规的OpenGL程序<strong>⾄少都会有两个缓冲区</strong>。显示在屏幕上的称为<strong>屏幕缓冲区</strong>，没有显示的称为<strong>离屏缓冲区</strong>。在⼀个缓冲区渲染完成之后，通过<strong>将屏幕缓冲区和离屏缓冲区交换</strong>，实现图像在屏幕上的显示。</li>
<li>由于<strong>显示器的刷新⼀般是逐⾏进行的</strong>，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，<strong>因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进⾏交换</strong>，这个信号就被称为<strong>垂直同步信号</strong>，这个技术被称为<strong>垂直同步</strong>。</li>
<li>使⽤了<strong>双缓冲区和垂直同步技术</strong>之后，由于总是要等待缓冲区交换之后再进⾏下⼀帧的渲染，使得帧率⽆法完全达到硬件允许的最⾼⽔平。为了解决这个问题，引⼊了<strong>三缓冲区技术</strong>，在等待垂直同步时，<strong>来回交替渲染两个离屏的缓冲区</strong>，⽽垂直同步发生时，<strong>屏幕缓冲区和最近渲染完成的离屏缓冲区交换</strong>，实现充分利⽤硬件性能的⽬的。</li>
</ul>
<h3 id="变换矩阵transformation">变换矩阵(Transformation)</h3>
<p>例如图形想发⽣平移,缩放,旋转变换.就需要使⽤变换矩阵.</p>
<h3 id="投影矩阵projection">投影矩阵(Projection)</h3>
<p>用于将3D坐标转换为⼆维屏幕坐标,实际线条也将在⼆维坐标下进⾏绘制。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#opengl">OpenGL</a></li>
<li><a href="#%E4%B8%8A%E4%B8%8B%E6%96%87context">上下文Context</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%9C%BA">状态机</a></li>
<li><a href="#%E6%B8%B2%E6%9F%93rendering">渲染（Rendering）</a></li>
<li><a href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84vertexarray%E5%92%8C%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BAvertexbuffer">顶点数组(VertexArray)和顶点缓冲区(VertexBuffer)</a></li>
<li><a href="#%E7%AE%A1%E7%BA%BF">管线</a></li>
<li><a href="#%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF%E5%AD%98%E5%82%A8%E7%9D%80%E8%89%B2%E5%99%A8">固定管线/存储着色器</a></li>
<li><a href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E7%AE%A1%E7%BA%BF">可编程管线</a></li>
<li><a href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8Fshader">着色器程序(Shader)</a></li>
<li><a href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8">顶点着色器</a></li>
<li><a href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8">片元着色器</a></li>
<li><a href="#glsl">GLSL</a></li>
<li><a href="#%E5%85%89%E6%A0%85%E5%8C%96rasterization">光栅化（Rasterization）</a></li>
<li><a href="#%E7%9D%80%E8%89%B2">着色</a></li>
<li><a href="#%E7%BA%B9%E7%90%86">纹理</a></li>
<li><a href="#%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE">纹理贴图</a></li>
<li><a href="#%E6%B7%B7%E5%90%88">混合</a></li>
<li><a href="#%E6%B8%B2%E6%9F%93%E4%B8%8A%E5%B1%8F%E4%BA%A4%E6%8D%A2%E7%BC%93%E5%86%B2%E5%8C%BAswapbuffer">渲染上屏/交换缓冲区(SwapBuffer)</a></li>
<li><a href="#%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5transformation">变换矩阵(Transformation)</a></li>
<li><a href="#%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5projection">投影矩阵(Projection)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://alanyangcn.github.io/post/de-feng-ge-ba/">
              <h3 class="post-title">
                Sign In with Apple 使用苹果账号登录你的应用
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '21fe59121bdf4cfd6884',
    clientSecret: 'a127c4be5aaf358472421ab5427228f65e868420',
    repo: 'alanyangcn.github.io',
    owner: 'alanyangcn',
    admin: ['alanyangcn'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
   | 
  <a class="rss" href="https://alanyangcn.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
