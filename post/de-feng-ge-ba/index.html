<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sign In with Apple 使用苹果账号登录你的应用 | 杨立鹏的个人博客</title>
<meta name="description" content="不积跬步无以至千里，不积小流无以成江海！" />
<link rel="shortcut icon" href="https://alanyangcn.github.io//favicon.ico?v=1574753759107">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://alanyangcn.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://alanyangcn.github.io/">
  <img class="avatar" src="https://alanyangcn.github.io//images/avatar.png?v=1574753759107" alt="">
  </a>
  <h1 class="site-title">
    杨立鹏的个人博客
  </h1>
  <p class="site-description">
    不积跬步无以至千里，不积小流无以成江海！
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Sign In with Apple 使用苹果账号登录你的应用
            </h2>
            <div class="post-info">
              <span>
                2019-11-26
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://alanyangcn.github.io//tag/tYrcfhTHH" class="post-tag">
                  # iOS
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://alanyangcn.github.io//post-images/de-feng-ge-ba.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p>苹果在 9 月 12 号更新了审核指南，加入 4.8 Sign in with Apple 一条，要求所有使用 第三方登录 的 App，都 必须接入 Sign in with Apple。符合以下条件的 App，可以不接入：</p>
</blockquote>
<blockquote>
<p>• 使用自建账户和登录系统；</p>
</blockquote>
<blockquote>
<p>• 要求用户使用现有的教育或企业账户登录的教育、企业或商业类应用；</p>
</blockquote>
<blockquote>
<p>• 使用政府或行业支持的公民身份识别系统或电子 ID 来验证用户；</p>
</blockquote>
<blockquote>
<p>• 应用特定于第三方服务，用户需要使用邮箱、社交媒体或其它第三方账户才能访问其内容的应用；</p>
</blockquote>
<blockquote>
<p>已经上架的 App 需在 2020 年 4 月 前完成接入工作，新上架 App（如果支持三方登录）必须接入，负责将被拒。</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>对于绝大部分应用，通常都会有自己的账号体系，但为了避免用户经常忘记账号密码，那些中小型 App 一般都会接入来自大厂的第三方登录 SDK，如在国外常见的有使用 Google、Facebook、Twitter、GitHub 等账号登录；而在国内，近两年几乎所有的 App 都会推荐首先使用手机号+短信验证码的方式注册/登录，同时也会接入像微信、QQ、微博、支付宝等超级 App 的登录 SDK，便于用户实现一键登录，如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqymx7FxQjG0KRH7reHYGnI9SI2FCflyUmiam3PraqJeD1Cr6nlAEEOTQ/640?wx_fmt=jpeg" alt="图片"></figure>
<p>在 WWDC 2019 上，苹果也想在第三方登录服务这块“蛋糕”上分一杯羹，给我们带来了 “Sign In with Apple”（使用苹果账号登录）。这似乎也是水到渠成的事，因为几乎所有的 iOS/macOS 设备都会登录 Apple ID，而且近两年来，苹果强制对所有的 Apple ID 推行 Two-Factor Authentication（2FA，双重因子验证），大大提高了苹果账号的安全性，减少了盗号风险。</p>
<p>因此，我们可以畅想在不久的将来，在苹果设备上，只要登录了 Apple ID，就可以直接登录所有的 App，是不是很方便？但这同时也是黑客们的福音啊...?</p>
<ol>
<li>概览<br>
<code>The fast, easy way to sign in to apps and websites.</code></li>
</ol>
<p>通过 Sign In with Apple，用户可以轻松登录开发者的应用和网站，开发者可以获取到以下三个信息用于创建自己的账号体系（下一节会细讲）：</p>
<p>ID</p>
<p>Full name</p>
<p>Verified email address</p>
<p>它具有如下几个特性，详见这里：</p>
<p>简化账号的创建和登录流程，无缝跨设备使用；</p>
<p>开发者可以获取到已验证过的邮箱作为登录账号或者与用户进行通信（注：用户可以选择隐藏真实邮箱，并使用苹果提供的虚拟邮箱进行授权）；</p>
<figure data-type="image" tabindex="2"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpq4Kse6ib6Mw1Cx0IGib46uMiaNUSnZue46Nw9iabezdhQdaRfDIMYPLeXXw/640?wx_fmt=jpeg" alt="图片"></figure>
<p>系统内置的安全性：2FA 双重验证（Face ID 或 Touch ID），从此登录不再需要密码；</p>
<p>尊重用户隐私：开发者仅仅可获取到用户的姓名和邮箱，同时苹果不会收集任何用户与应用之间使用数据；</p>
<p>反欺诈：使用设备上的机器学习等技术和其他信息，帮助开发者判断一个账号是否为真实用户；</p>
<p>最重要的是，它是跨平台的！！！</p>
<figure data-type="image" tabindex="3"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqBTHzcMPBQDKFwhIicImHqiaKeBJ6Ct2uxDfFO6pmPNMUib0eYhXQYFIKA/640?wx_fmt=jpeg" alt=""></figure>
<ol start="3">
<li>如何集成<br>
在你的 App 中集成 “Sign In with Apple” 服务，大致只需要以下 4 步骤：</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqk1US6DSISpnKKSyUqNHcsdQT0txnmqIdS6vHO6MPicomNZHD7DyRvmw/640?wx_fmt=jpeg" alt=""></figure>
<p>4.1 添加登录按钮<br>
首先，在你 App 的登录页面添加一个 “Sign In with Apple” 按钮 ASAuthorizationAppleIDButton，并添加按钮点击响应事件，代码大致如下：</p>
<pre><code>// Add “Sign In with Apple” button to your login viewfunc setupProviderLoginView() {
    let authorizationButton = ASAuthorizationAppleIDButton()authorizationButton.addTarget(self, action: #selector(handleAuthorizationAppleIDButtonPress), for: .touchUpInside)self.loginProviderStackView.addArrangedSubview(authorizationButton)
    }
</code></pre>
<p>当然你也可以自定义苹果登录按钮的样式，样式要求详见这个文档：Human Interface Guidelines</p>
<p>最终的登录页面效果图参考如下：</p>
<figure data-type="image" tabindex="5"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpq8zI2zEzXHibl7DibJ4R35fqleNn11iaBMQuhmZJ14W7oDb053qBIXwkaw/640?wx_fmt=jpeg" alt=""></figure>
<p>4.2 发起授权请求<br>
在上述按钮点击事件 handleAuthorizationAppleIDButtonPress 中配置需要获取的数据权限范围（例如：用户名、邮箱等），然后设置回调代理，并发起登录授权请求，代码如下：</p>
<p>// Configure request, setup delegates and perform authorization request@objc func handleAuthorizationAppleIDButtonPress() {let appleIDProvider = ASAuthorizationAppleIDProvider()let request = appleIDProvider.createRequest()request.requestedScopes = [.fullName, .email]let authorizationController = ASAuthorizationController(authorizationRequests: [request])authorizationController.delegate = selfauthorizationController.presentationContextProvider = selfauthorizationController.performRequests()}<br>
当用户点击 “Sign In with Apple” 按钮后，就会显示苹果登录授权确认页面，如下图所示：</p>
<figure data-type="image" tabindex="6"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqPV590b0dmBEhyTSr9zMJtZia4PhmtItmgtxicyLGgZBibgskkEamibU0nA/640?wx_fmt=jpeg" alt=""></figure>
<p>在该页面，用户可以选择是否给你返回他的名字和真实邮箱，当然用户也可以选择隐藏自己的邮箱，此时开发者会得到一个虚拟的用户邮箱地址（此邮箱收到的邮件会转发到用户真实的邮箱上）。当用户点击 “Continue” 按钮后，会进行 “Touch ID” 或者 “Face ID” 双重验证，然后回调数据给开发者。</p>
<p>4.3 处理回调，服务端验证结果<br>
我们需要在代码中实现两个代理回调 ASAuthorizationControllerDelegate、ASAuthorizationControllerPresentationContextProviding 分别用于处理授权登录成功和失败、以及提供用于展示授权页面的 Window，代码如下：</p>
<p>/// MARK: ASAuthorizationControllerDelegatefunc authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {if let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential {let userIdentifier = appleIDCredential.userlet fullName = appleIDCredential.fullNamelet email = appleIDCredential.emaillet realUserStatus = credential.realUserStatuslet identityToken = credential.identityTokenlet authCode = credential.authorizationCode// Create account in your system}}func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {// Handle error.}/// MARK: ASAuthorizationControllerPresentationContextProvidingfunc presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor {return self.view.window!}<br>
在授权成功回调中，我们可以拿到以下几类数据：</p>
<p>User ID: Unique, stable, team-scoped user ID，苹果用户唯一标识符，该值在同一个开发者账号下的所有 App 下是一样的，开发者可以用该唯一标识符与自己后台系统的账号体系绑定起来（这与国内的微信、QQ、微博等第三方登录流程基本一致）。</p>
<p>Verification data: Identity token, code，验证数据，用于传给开发者后台服务器，然后开发者服务器再向苹果的身份验证服务端验证本次授权登录请求数据的有效性和真实性，详见 Sign In with Apple REST API。如果验证成功，可以根据 userIdentifier 判断账号是否已存在，若存在，则返回自己账号系统的登录态，若不存在，则创建一个新的账号，并返回对应的登录态给 App。</p>
<p>Account information: Name, verified email，苹果用户信息，包括全名、邮箱等。</p>
<p>Real user indicator: High confidence indicator that likely real user，用于判断当前登录的苹果账号是否是一个真实用户，取值有：unsupported、unknown、likelyReal。</p>
<p>4.4 处理苹果账号会话发生变化<br>
当开发者的 App 通过苹果账号登录后，iOS/macOS 设备上登录的 Apple ID 发生变化时，例如：</p>
<p>设备上的 Apple ID 退出登录、切换新的账号登录；</p>
<p>用户在设置页面禁止 App 使用苹果账号登录，如下图：</p>
<figure data-type="image" tabindex="7"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqAjc5ChXHrTGILickCZ1njuE80yE8LILib4ib3nEsGWicv3YnAKPmWyW5SQ/640?wx_fmt=jpeg" alt=""></figure>
<p>此时，也需要通知到 App 做账号登出处理。因此，我们可以 App 启动时，调用 ASAuthorizationAppleIDProvider 的 getCredentialState 方法，传入当前用户的 UserIdentifier 进行判断：</p>
<p>let appleIDProvider = ASAuthorizationAppleIDProvider()appleIDProvider.getCredentialState(forUserID: &quot;currentUserIdentifier&quot;) { (credentialState, error) inswitch credentialState {case .authorized:// The Apple ID credential is validbreakcase .revoked:// Apple ID Credential revoked, handle unlinkbreakcase .notFound:// Credential not found, show login UIbreakdefault:break}}<br>
苹果称，该 API 的速度非常快，我们可以在 App 每次启动时调用，然后根据结果做相应的处理：</p>
<p>authorized：登录状态有效；</p>
<p>revoked：上次使用苹果账号登录的凭据已被移除，需退出解除绑定并重新引导使用苹果登录；</p>
<p>notFound：未登录，直接显示开发者 App 的登录页面。</p>
<p>此外，苹果也提供了通知的方式来监听，在 App 使用过程中，当苹果账号发生变化时做相应的处理：</p>
<p>// Register for revocation notificationlet center = NotificationCenter.defaultlet name = NSNotification.Name.ASAuthorizationAppleIDProviderCredentialRevokedlet observer = center.addObserver(forName: name, object: nil, queue: nil) { (Notification) in// Sign the user out, optionally guide them to sign in again}<br>
4.5 快速登录已有账户<br>
如果一个 Apple ID 之前已在 App 中授权登录过了，此时点击 “Sign In with Apple” 会直接显示如下页面：</p>
<figure data-type="image" tabindex="8"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpqYx4iacGmILpeeFabdr3pT1BkjicRclPzRBtu4niaHEM6J2b4xgpL0SsibA/640?wx_fmt=jpeg" alt=""></figure>
<p>或者 App 上次用自己的账号/密码登录后保存在 Keychain 中，此时可以在登录页面直接请求读取密码进行自动填充：</p>
<figure data-type="image" tabindex="9"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpq8g3jtgCh2uYJicM9jkETsDWEiaRQp5EbPlkdWZtkW5n7mHwnlSAgEWSw/640?wx_fmt=jpeg" alt=""></figure>
<p>对于读取 Keychain 中保存的密码，苹果提供了与授权登录类似的 API，我们可以在登录页面的 viewDidAppear 方法中执行代码如下：</p>
<p>/// Prompts the user if an existing iCloud Keychain credential or Apple ID credential is found.func performExistingAccountSetupFlows() {// Prepare requests for both Apple ID and password providers.let requests = [ASAuthorizationAppleIDProvider().createRequest(),ASAuthorizationPasswordProvider().createRequest()]// Create an authorization controller with the given requests.let authorizationController = ASAuthorizationController(authorizationRequests: requests)authorizationController.delegate = selfauthorizationController.presentationContextProvider = selfauthorizationController.performRequests()}<br>
然后在回调方法中进行判断：</p>
<p>func authorizationController(controller _: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {switch authorization.credential {case let credential as ASAuthorizationAppleIDCredential:let userIdentifier = credential.user// Sign the user in using the Apple ID credentialcase let credential as ASPasswordCredential:// Sign the user in using their existing password credentialdefault: break}}</p>
<h2 id="补充">补充</h2>
<p>App 要集成苹果账号登录，必须在 Xcode 工程的 Signing &amp; Capabilities tab 中添加 “Sign In with Apple” 能力，需登录相应的开发者账号；</p>
<p>调试时，必须使用运行最新系统版本的真机设备，且设备上登录的 Apple ID 必须开启 2FA 双重验证；</p>
<p>上述示例代码完整的 Demo，详见这里：Adding the Sign In with Apple Flow to Your App</p>
<ol start="4">
<li>跨平台 - JavaScript SDK<br>
“Sign In with Apple” 最大的杀手锏在于跨平台，除了苹果自己生态内的系统，苹果还提供了 JavaScript SDK，使得在 Web 应用中也能很方便地使用该服务。因为 Web 本身是跨平台的，所以理论上在 Windows 或者 Android 操作系统上也可以使用苹果账号登录啦~</li>
</ol>
<p>iOS, macOS, tvOS, and watchOS: Native API</p>
<p>Web / Windows / Android: Javascript SDK</p>
<figure data-type="image" tabindex="10"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/TicZ5mBTTCu0Yvib0DH1icXvvHEDKTGWhpquShibE2FpLn98SuCiaI4IAKG23xgRibicT5jvP9GgiaM7l4AzEbOWK4wS4g/640?wx_fmt=jpeg" alt=""></figure>
<p>它具有如下 3 个特性：</p>
<p>Simple browser-based login：点击 Web 页面上的苹果登录按钮，跳转到苹果网站进行登录，然后苹果会把登录结果回调给开发者填写的 redirectUri；</p>
<p>Similar to native API：JS API 与原生 API 类似，简单易用；</p>
<p>Native experience when using Safari：如果用户使用 Safari 浏览器访问 Web，则会默认调用 Native API 进行授权登录操作；</p>
<p>JavaScript SDK 的使用步骤大致如下：</p>
<p>Include：引入 SDK 依赖</p>
<p><code>&lt;script src=&quot;https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js&quot;&gt;</code><br>
Button：添加苹果登录按钮，并自定义样式</p>
<p><code>&lt;div id=&quot;appleid-signin&quot;&gt;&lt;/div&gt;</code><br>
Configure：登录信息配置，设置回调 URL</p>
<p><code>AppleID.auth.init({clientId : 'com.example.webapp',scope : 'name email',redirectURI : 'https://example.com/redirectUri',state : 'state'});</code><br>
Result：服务端处理登录回调结果</p>
<p><code>POST /redirectUri</code><br>
关于苹果登录的 JS SDK 更详细的内容，请参考这里：Sign In with Apple JS</p>
<ol start="5">
<li>App Store 审核<br>
在最近更新的苹果应用商店审核指南 Updates to the App Store Review Guidelines 中，有如下一段话：</li>
</ol>
<blockquote>
<p>We’ve updated the App Store Review Guidelines to provide criteria for when apps are required to use Sign in with Apple. Starting today, new apps submitted to the App Store must follow these guidelines. Existing apps and app updates must follow them by April 2020. We’ve also provided new guidelines for using Sign in with Apple on the web and other platforms.</p>
</blockquote>
<p>也就是说，所有已接入其它第三方登录的 App 也必须在 2020 年 4 月前完成接入工作，而新上架提交的 App 必须完成接入工作，否则可能就不给过（当然，那些只有自己账号体系登录的 App 就不用担心了），苹果爸爸还真是强势，所以，适配工作赶快行动起来吧~</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%BC%95%E8%A8%80">引言</a></li>
<li><a href="#%E8%A1%A5%E5%85%85">补充</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '21fe59121bdf4cfd6884',
    clientSecret: 'a127c4be5aaf358472421ab5427228f65e868420',
    repo: 'alanyangcn.github.io',
    owner: 'alanyangcn',
    admin: ['alanyangcn'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
   | 
  <a class="rss" href="https://alanyangcn.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
